# Database Migration Strategy

## Overview

Content Creation Crew uses **Alembic** for database schema migrations. This document describes the migration workflow, naming conventions, and deployment procedures.

## Table of Contents

1. [Alembic Basics](#alembic-basics)
2. [Migration Workflow](#migration-workflow)
3. [Naming Conventions](#naming-conventions)
4. [Creating Migrations](#creating-migrations)
5. [Running Migrations](#running-migrations)
6. [Deployment Strategy](#deployment-strategy)
7. [Migration Policies](#migration-policies)
8. [Troubleshooting](#troubleshooting)

---

## Alembic Basics

### What is Alembic?

Alembic is a database migration tool for SQLAlchemy. It tracks schema changes in version-controlled Python files and applies them to your database.

### Key Concepts

- **Revision**: A single migration file (e.g., `0607bc5b8535_initial_authentication_schema.py`)
- **Head**: The latest migration revision
- **Current**: The migration revision currently applied to the database
- **Upgrade**: Apply migrations forward (upgrade schema)
- **Downgrade**: Rollback migrations backward (downgrade schema)

### Migration Files Location

```
alembic/
├── env.py              # Alembic environment configuration
├── script.py.mako      # Migration template
└── versions/           # Migration files
    ├── 0607bc5b8535_initial_authentication_schema.py
    └── 0607bc5b8536_add_media_generation_counters.py
```

---

## Migration Workflow

### Development Workflow

1. **Modify Models**: Update SQLAlchemy models in `src/content_creation_crew/db/models/`
2. **Generate Migration**: Create migration file with autogenerate
3. **Review Migration**: Check generated SQL and adjust if needed
4. **Test Migration**: Apply migration locally and test
5. **Test Rollback**: Verify rollback works correctly
6. **Commit**: Commit migration file to version control

### Production Workflow

1. **Backup Database**: Create backup before migration
2. **Apply Migration**: Run migration during deployment
3. **Verify**: Check application health and functionality
4. **Monitor**: Watch for errors or performance issues

---

## Naming Conventions

### Migration File Names

**Format:** `{revision_id}_{descriptive_slug}.py`

**Examples:**
- `0607bc5b8535_initial_authentication_schema.py`
- `0607bc5b8536_add_media_generation_counters.py`
- `abc123def456_add_user_preferences_table.py`

### Revision IDs

- **Auto-generated**: Alembic generates unique revision IDs (12-character hex)
- **Manual**: Can specify custom revision ID (not recommended)

### Descriptive Slugs

**Guidelines:**
- Use lowercase with underscores
- Be descriptive but concise
- Include the main change (e.g., `add_`, `remove_`, `modify_`, `rename_`)
- Examples:
  - ✅ `add_user_preferences_table`
  - ✅ `remove_old_session_columns`
  - ✅ `modify_subscription_status_enum`
  - ❌ `fix` (too vague)
  - ❌ `changes` (not descriptive)

---

## Creating Migrations

### Method 1: Autogenerate (Recommended)

**When to use:** After modifying SQLAlchemy models

```bash
# Generate migration from model changes
alembic revision --autogenerate -m "add_user_preferences_table"

# Or using Makefile
make migrate-create MESSAGE="add_user_preferences_table"
```

**What it does:**
- Compares current models with database schema
- Generates `upgrade()` and `downgrade()` functions
- Creates migration file in `alembic/versions/`

**Important:** Always review autogenerated migrations before applying!

### Method 2: Empty Migration (Manual)

**When to use:** For data migrations, complex changes, or when autogenerate fails

```bash
# Create empty migration file
alembic revision -m "migrate_user_data_to_new_format"

# Then manually write upgrade() and downgrade() functions
```

**Example:**
```python
def upgrade() -> None:
    # Custom SQL or data migration logic
    op.execute("UPDATE users SET status = 'active' WHERE status IS NULL")
    
def downgrade() -> None:
    # Reverse the migration
    op.execute("UPDATE users SET status = NULL WHERE status = 'active'")
```

### Reviewing Generated Migrations

**Always check:**
1. **Correctness**: Does it do what you expect?
2. **Completeness**: Are all model changes captured?
3. **Safety**: Will it cause data loss?
4. **Performance**: Will it lock tables for long?
5. **Rollback**: Is `downgrade()` correct?

**Common Issues:**
- Autogenerate misses some changes (add manually)
- Autogenerate includes unwanted changes (remove manually)
- Missing indexes or constraints (add manually)
- Data migration needed (add custom logic)

---

## Running Migrations

### Local Development

**Option 1: Using Makefile (Recommended)**
```bash
# Apply all pending migrations
make migrate-up

# Check current migration status
make migrate-current

# Rollback last migration
make migrate-down-one
```

**Option 2: Using Alembic Directly**
```bash
# Apply all pending migrations
alembic upgrade head

# Apply one migration at a time
alembic upgrade +1

# Check current revision
alembic current

# Show migration history
alembic history
```

**Option 3: Using migrate_db.py Script**
```bash
# Apply all migrations
python migrate_db.py

# Or explicitly
python migrate_db.py upgrade

# Check current revision
python migrate_db.py current
```

### Docker Development

```bash
# Run migrations in Docker container
docker compose exec api alembic upgrade head

# Or using Makefile
make migrate
```

### Automatic Migration on Startup

**Current Behavior:**
- Migrations run automatically on application startup via `init_db()`
- Located in `src/content_creation_crew/database.py`
- Logs success/failure but doesn't block startup

**Pros:**
- Convenient for development
- Ensures database is up-to-date

**Cons:**
- Can cause issues in production if migration fails
- Multiple instances might try to migrate simultaneously

**Production Recommendation:**
- Run migrations as a separate deployment step (see [Deployment Strategy](#deployment-strategy))

---

## Deployment Strategy

### Staging/Production: Separate Migration Job

**Recommended Approach:** Run migrations as a separate step before deploying application code.

#### Option 1: Pre-Deployment Migration Script

**Create:** `scripts/migrate_production.sh`
```bash
#!/bin/bash
set -e

echo "Running database migrations..."

# Check database connection
python -c "from content_creation_crew.db.engine import test_connection; exit(0 if test_connection() else 1)"

# Run migrations
alembic upgrade head

echo "✓ Migrations completed successfully"
```

**Usage in CI/CD:**
```yaml
# Example GitHub Actions / GitLab CI
- name: Run Database Migrations
  run: |
    bash scripts/migrate_production.sh
  env:
    DATABASE_URL: ${{ secrets.DATABASE_URL }}
```

#### Option 2: Migration Container (Kubernetes)

**Create:** `kubectl job` that runs migrations before deployment:
```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: db-migration-{{ timestamp }}
spec:
  template:
    spec:
      containers:
      - name: migrate
        image: content-crew-api:latest
        command: ["alembic", "upgrade", "head"]
        env:
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: db-credentials
              key: url
      restartPolicy: Never
```

#### Option 3: Railway/Heroku Release Phase

**Railway:**
```json
{
  "build": {
    "builder": "DOCKERFILE"
  },
  "deploy": {
    "startCommand": "python api_server.py",
    "releaseCommand": "alembic upgrade head"
  }
}
```

**Heroku:**
```procfile
release: alembic upgrade head
web: python api_server.py
```

### Migration Lock Strategy

**Problem:** Multiple instances trying to migrate simultaneously

**Solution:** Use database-level locking or run migrations in a single instance

**Alembic Lock Table:**
- Alembic uses `alembic_version` table as a lock
- Only one migration can run at a time
- If migration fails, lock may persist (manual cleanup needed)

**Best Practice:**
- Run migrations in a single, dedicated migration job
- Wait for migration to complete before deploying application code
- Use health checks to verify migration success

---

## Migration Policies

### Forward-Only Policy

**Default:** Migrations are forward-only (no rollbacks in production)

**Rationale:**
- Rollbacks can cause data loss
- Production data may depend on new schema
- Safer to fix forward with a new migration

**When Rollbacks Are Allowed:**
- Development/staging environments
- Immediately after deployment (before data is written)
- With explicit approval and data backup

### Destructive Migrations

**Definition:** Migrations that delete data or columns

**Policy:**
- **Never** delete columns without deprecation period
- **Always** document data loss risks
- **Require** explicit approval for destructive changes

**Example Destructive Migration:**
```python
def upgrade() -> None:
    # ⚠️ DESTRUCTIVE: Removes column with user preferences
    # Data will be lost! Ensure data is migrated first.
    op.drop_column('users', 'old_preferences')
```

**Safe Alternative:**
```python
def upgrade() -> None:
    # Step 1: Add new column
    op.add_column('users', sa.Column('preferences_json', sa.JSON()))
    
    # Step 2: Migrate data (custom logic)
    op.execute("""
        UPDATE users 
        SET preferences_json = json_build_object('theme', old_preferences)
        WHERE old_preferences IS NOT NULL
    """)
    
    # Step 3: Mark old column as deprecated (in separate migration)
    # op.drop_column('users', 'old_preferences')  # Do in next migration
```

### Data Migrations

**When Needed:**
- Transforming existing data
- Populating new required fields
- Fixing data inconsistencies

**Best Practices:**
- Test on staging with production data copy
- Make idempotent (safe to run multiple times)
- Include rollback logic in `downgrade()`

**Example:**
```python
def upgrade() -> None:
    # Migrate user status values
    op.execute("""
        UPDATE users 
        SET status = 'active' 
        WHERE status IS NULL OR status = ''
    """)

def downgrade() -> None:
    # Rollback: Set back to NULL
    op.execute("""
        UPDATE users 
        SET status = NULL 
        WHERE status = 'active'
    """)
```

---

## Troubleshooting

### Migration Fails: "Target database is not up to date"

**Problem:** Database is at an older revision than expected

**Solution:**
```bash
# Check current revision
alembic current

# Check available migrations
alembic history

# Apply missing migrations
alembic upgrade head
```

### Migration Fails: "Can't locate revision identified by 'xyz'"

**Problem:** Migration file is missing or revision chain is broken

**Solution:**
```bash
# Check migration files
ls alembic/versions/

# Verify revision chain
alembic history --verbose

# If revision is missing, restore from git or recreate
```

### Migration Hangs: Database Lock

**Problem:** Another migration is running or previous migration failed

**Solution:**
```bash
# Check for running migrations
ps aux | grep alembic

# Check alembic_version table
psql $DATABASE_URL -c "SELECT * FROM alembic_version;"

# If stuck, manually update alembic_version (use with caution!)
```

### Autogenerate Misses Changes

**Problem:** Model changes not detected by autogenerate

**Common Causes:**
- Models not imported in `alembic/env.py`
- Changes in relationships or constraints
- Custom SQLAlchemy types

**Solution:**
1. Ensure all models are imported in `alembic/env.py`
2. Manually add missed changes to migration
3. Use empty migration for complex changes

### Migration Conflicts in Team

**Problem:** Multiple developers create migrations simultaneously

**Solution:**
1. **Rebase:** Merge latest migrations first
2. **Rename:** Update migration file name if needed
3. **Fix:** Update `down_revision` to point to correct parent
4. **Test:** Verify migration chain works

---

## Best Practices

### ✅ DO

- ✅ Always review autogenerated migrations
- ✅ Test migrations on staging before production
- ✅ Test rollback procedures
- ✅ Use descriptive migration names
- ✅ Keep migrations small and focused
- ✅ Document data migrations
- ✅ Backup database before production migrations
- ✅ Run migrations in transaction (Alembic default)

### ❌ DON'T

- ❌ Don't modify existing migration files (create new ones)
- ❌ Don't delete migration files (they're part of history)
- ❌ Don't skip testing rollbacks
- ❌ Don't run destructive migrations without approval
- ❌ Don't run migrations manually in production (use automation)
- ❌ Don't ignore migration failures

---

## Related Documentation

- [Migration Rollback Guide](./migration-rollback.md) - How to rollback migrations
- [Pre-Deploy Readiness](./pre-deploy-readiness.md) - Deployment checklist
- [Database Schema](../ARCHITECTURE.md#database-schema) - Current schema documentation

---

**Last Updated:** January 13, 2026  
**Alembic Version:** 1.13.0+  
**Status:** ✅ Production Ready

